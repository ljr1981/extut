# Extut - Elixir Tutorial

This projects code is contained in a single deffunction of M.ex (see libs folder).

It is my typed code based on following the YouTube tutorial at:

https://youtu.be/pBNOavRoNL0

The code is not just a "tag-along" follow of the presenter (Derek Banas). I do take some liberties with the code (and will do a review over time and learning as I gain more knowledge).

# How I am learning Elixir and Phoenix (so far)

A podcast titled, "Thinking Elixir" had a guest who was asked, "How did you all learn Elixir?" The answer was interesting:

- Udemy (paid training courses)
- Documentation (Guides)
- YouTube (with caveats)
- Books (also with caveats)
- Pair Programming
- Reading Others Code
- Doing

## Udemy (paid training)

I started with some Udemy paid training. The problem quickly arose that the class was five years old and both Elixir and (especially) Phoenix had changed dramatically. However—the loss was minial (e.g. $12). So, I wasn't out too much money. So, like other training materials, check the age of the course and ensure that it is relatively recent and matches your installed Elixir and Phoenix (as well as Erlang and Ecto).

## Documentation

By this—I specifically mean—the documentation on Elixir and Phoenix web sites (e.g. www.elixir-lang.org and www.phoenixframework.org). There is also excellent documentation for Ecto (the Elixir database interaction framework), which I have not dug into just yet.

## YouTube (with caveats)

Elixir is such a new language that its core is still (somewhat) evolving, changing, and growing. Because this is true, older video material will often be out-of-date with special regard to framework organization and use. While the Elixir language and core Erlang are quite solid, the frameworks built on them goes through changes rather frequently. However, the entire language system and its frameworks are stabilizing. Nevertheless—it is wise to choose video instruction that is concurrent with the version of Erlang, Elixir, and Phoenix (or whatever framework you are learning).

## Books (also with caveats)

Books are even more prone to being out-of-date with whatever the most current versions of Erlang, Elixir, and Phoenix one is downloading and installing.

NOTE: Alternatively, you can download and install older versions of these technologies. There are version management programs you can use, like 'asdf" or "kiex". For example: I have the following versions installed as of this writing:

'''
defp deps do
    [
      {:phoenix, "~> 1.6.12"},
      {:phoenix_ecto, "~> 4.4"},
      {:ecto_sql, "~> 3.6"},
      {:postgrex, ">= 0.0.0"},
      {:phoenix_html, "~> 3.0"},
      {:phoenix_live_reload, "~> 1.2", only: :dev},
      {:phoenix_live_view, "~> 0.17.5"},
      {:floki, ">= 0.30.0", only: :test},
      {:phoenix_live_dashboard, "~> 0.6"},
      {:esbuild, "~> 0.4", runtime: Mix.env() == :dev},
      {:swoosh, "~> 1.3"},
      {:telemetry_metrics, "~> 0.6"},
      {:telemetry_poller, "~> 1.0"},
      {:gettext, "~> 0.18"},
      {:jason, "~> 1.2"},
      {:plug_cowboy, "~> 2.5"},
      {:tailwind, "~> 0.1.6", runtime: Mix.env() == :dev}
    ]
  end
'''

The list above is from the `mix.exs` dependencies configuration file.

- Phoenix — The Elixir web server (and framework)
- Phoenix Ecto — The Elixir database management framework
- Ecto SQL — The query language framework
- and so on ...

## Pair Programming

Learning with someone else can be easier. It is best to have two sets of eyes and brains reading and consuming documentation, videos, and books. I highly recommend reading the books in a "book clud" fashion and having a discussion—chapter by chapter. Also—be sure to do the exercises!

## Reading Others Code

There are several meaningful sources of "others code" that helps:

- Generated code — for example: when creating a new Elixir Phoenix web app project, it is helpful to read the code and follow along with the Phoenix Guide on the subject, where the documentation outlines what code was generated, the organization of that code, the purpose of the directory structures and the files within them. There are also explanations of naming conventions that are adhered to by Phoenix as a framework. Ecto has this same idea as well as do most Elixir frameworks.
- Book and Documenation code — In many books and online guides, you will find plenty of code with explanations.
- Other programmers — get a network of programmers around you. Read their code. Share yours. Meetup groups are a great way to do this. Also—there is Stackoverflow and Slack.

### Generated Code

I cannot stress reading and understanding, discecting code generated by the `mix` program. For example: I finally came upon a section of the Phoenix Guide that mentioned using a call to `mix` to generate Phoenix Live code with a front-end form coupled with the creation of a database table with fields. Once I knew I could run this generator, I then stopped and closely read, examined, understood, and comprehended each file created, its purpose, and the semantics and syntax of it all. This took me lightyears down a road that I could not previously see.

## (Finally) Doing

Start coding. Start attempting to make something work.

# Tools

I highly recommend VSCode as your IDE and code editor. There are excellent add-ons that will format and prettify your code as well as some basic linters and so on. Overall, my experience with VSCode has been postive.

I also suggest using several browsers (e.g. Edge, Chrome, Firefox, Safari, and so on). This is just a good idea for any web app development project and working environment. Your browswer has all sorts of helpful built-in tools for you as a developer to learn and use.

# Testing

Elixir has plently of testing facilities and Phoenix Live makes end-to-end testing with a browser much simppler (e.g. you don't need the browser as much as you would without it). There is some capacity for Elixir to build its own tests of your code based on some structured comments that you create. So, not only do your comments get collected into what turn into "help files", but the comments are read by the testing facility of Elixir and turned into functional code tests.

# Conclusion

There are probably items I am leaving out and links that I need to add, but this is all I can think of at the moment. Besides, I am working off my phone in a very small town in SE KS at the moment with the most abysmal throughput and latency to the internet I have experienced since the 1980s!

I will add more once I am back in civilization again! :-)
